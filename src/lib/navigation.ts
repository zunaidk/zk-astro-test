/**
 * Navigation Helpers for Astro
 * 
 * Auto-generated by PhantomWP
 * 
 * Usage in Astro components:
 * ---
 * import { getNavigationPages, getMenuItems, isActivePath, getBreadcrumbs } from '../lib/navigation';
 * const pages = await getNavigationPages();
 * const menuItems = await getMenuItems(); // Use this for custom menus with hierarchy
 * ---
 */

// ============================================================================
// Types
// ============================================================================

export interface NavigationPage {
  url: string;
  title: string;
  slug: string;
}

export interface MenuItem {
  id: string;
  type: 'home' | 'page' | 'wp_page' | 'custom';
  label: string;
  url: string;
  wpPageId?: number;
  children?: MenuItem[];
}

export interface MenuConfig {
  items: MenuItem[];
  showHome: boolean;
  excludedPages: string[];
  useCustomMenu: boolean;
}

export interface BreadcrumbItem {
  label: string;
  href: string;
  current: boolean;
}

// ============================================================================
// Menu Configuration
// ============================================================================

let menuConfig: MenuConfig | null = null;

/**
 * Load menu configuration from src/config/menus.json
 * Returns null if file doesn't exist or custom menu is disabled
 */
async function loadMenuConfig(): Promise<MenuConfig | null> {
  if (menuConfig !== null) return menuConfig;
  
  try {
    // Try to import the new menus.json config (from Menu Builder)
    const config = await import('../config/menus.json');
    if (config.default && config.default.menus && config.default.menus.length > 0) {
      // Convert new format to MenuConfig format - use first menu as default
      const firstMenu = config.default.menus[0];
      menuConfig = {
        items: firstMenu.items || [],
        showHome: firstMenu.showHome ?? true,
        excludedPages: config.default.excludedPages || [],
        useCustomMenu: true,
      };
      return menuConfig;
    }
  } catch {
    // New format doesn't exist, try legacy format
  }
  
  try {
    // Legacy: Try to import the old menu.json config
    const config = await import('../config/menu.json');
    if (config.default && config.default.useCustomMenu) {
      menuConfig = config.default as MenuConfig;
      return menuConfig;
    }
  } catch {
    // File doesn't exist or parse error - use auto-discovery
  }
  
  return null;
}

/**
 * Get menu items from the custom menu configuration
 * Returns the hierarchical menu structure with children for dropdowns
 * 
 * Usage:
 * ```astro
 * ---
 * import { getMenuItems } from '../lib/navigation';
 * const items = await getMenuItems();
 * ---
 * 
 * <nav>
 *   {items.map(item => (
 *     <div>
 *       <a href={item.url}>{item.label}</a>
 *       {item.children && (
 *         <div class="dropdown">
 *           {item.children.map(child => (
 *             <a href={child.url}>{child.label}</a>
 *           ))}
 *         </div>
 *       )}
 *     </div>
 *   ))}
 * </nav>
 * ```
 */
export async function getMenuItems(): Promise<MenuItem[]> {
  const config = await loadMenuConfig();
  if (config && config.useCustomMenu) {
    return config.items;
  }
  
  // Fall back to auto-discovery (flat list)
  const pages = await getNavigationPages();
  return pages.map(page => ({
    id: 'auto_' + page.slug,
    type: page.url === '/' ? 'home' : 'page' as const,
    label: page.title,
    url: page.url,
  }));
}

/**
 * Check if menu has custom configuration enabled
 */
export async function hasCustomMenu(): Promise<boolean> {
  const config = await loadMenuConfig();
  return config !== null && config.useCustomMenu;
}

/**
 * Get menu items by menu name/slug
 * Useful when you have multiple menus (e.g., main, footer, sidebar)
 * 
 * Usage:
 * ```astro
 * ---
 * import { getMenuByName } from '../lib/navigation';
 * const footerMenu = await getMenuByName('footer');
 * ---
 * 
 * {footerMenu && (
 *   <nav>
 *     {footerMenu.items.map(item => (
 *       <a href={item.url}>{item.label}</a>
 *     ))}
 *   </nav>
 * )}
 * ```
 */
export async function getMenuByName(nameOrSlug: string): Promise<{ name: string; items: MenuItem[]; style: string } | null> {
  try {
    const config = await import('../config/menus.json');
    if (config.default && config.default.menus) {
      const menu = config.default.menus.find(
        (m: any) => m.name.toLowerCase() === nameOrSlug.toLowerCase() || m.slug === nameOrSlug
      );
      if (menu) {
        return {
          name: menu.name,
          items: menu.items || [],
          style: menu.style || 'horizontal',
        };
      }
    }
  } catch {
    // Config doesn't exist
  }
  return null;
}

/**
 * Get all available menu names
 * Useful for debugging or dynamic menu selection
 */
export async function getAvailableMenus(): Promise<string[]> {
  try {
    const config = await import('../config/menus.json');
    if (config.default && config.default.menus) {
      return config.default.menus.map((m: any) => m.name);
    }
  } catch {
    // Config doesn't exist
  }
  return [];
}

// ============================================================================
// Page Discovery
// ============================================================================

/**
 * Get all top-level pages for navigation (excluding blog posts, index, 404, dynamic routes)
 * 
 * Note: If a custom menu is configured, this still returns auto-discovered pages
 * but they will be filtered by excludedPages if set.
 * 
 * For hierarchical menus with dropdowns, use getMenuItems() instead.
 * 
 * Usage:
 * ```astro
 * ---
 * import { getNavigationPages } from '../lib/navigation';
 * const pages = await getNavigationPages();
 * ---
 * 
 * <nav>
 *   {pages.map(page => (
 *     <a href={page.url}>{page.title}</a>
 *   ))}
 * </nav>
 * ```
 */
export async function getNavigationPages(): Promise<NavigationPage[]> {
  // Load config to check for excluded pages
  const config = await loadMenuConfig();
  const excludedPages = config?.excludedPages || [];
  
  const pageFiles = import.meta.glob('../pages/**/*.{md,mdx,astro}', { eager: true });
  
  // Convert file paths to URLs and filter appropriately
  return Object.entries(pageFiles)
    .map(([filePath, module]) => {
      // Convert file path to URL: '../pages/products/index.astro' -> '/products'
      let url = filePath
        .replace('../pages', '')
        .replace(/\.astro$/, '')
        .replace(/\.mdx?$/, '')
        .replace(/\/index$/, '') // /products/index -> /products
        || '/';
      
      const frontmatter = module && typeof module === 'object' && 'frontmatter' in module 
        ? (module as any).frontmatter 
        : {};
      
      return { filePath, url, frontmatter };
    })
    .filter(({ url, filePath }) => {
      // Exclude blog posts, index, 404, offline, dynamic routes, and taxonomy/archive pages
      return (
        !url.includes('/blog') &&
        url !== '/' &&
        url !== '/404' &&
        url !== '/offline' &&
        url !== '/category' &&
        url !== '/tag' &&
        url !== '/author' &&
        !filePath.includes('[') && // Exclude dynamic routes like [slug]
        !filePath.includes(']') &&
        !excludedPages.includes(url) // Exclude pages from menu config
      );
    })
    .filter(({ url }) => {
      // Only top-level pages (e.g., /products, /about, but not /products/details)
      const segments = url.split('/').filter(Boolean);
      return segments.length === 1;
    })
    .map(({ url, frontmatter }) => {
      const slug = url.split('/').filter(Boolean)[0] || '';
      const defaultTitle = slug.replace(/-/g, ' ').replace(/_/g, ' ');
      // Capitalize each word if no frontmatter title exists
      const capitalizedTitle = defaultTitle
        .split(' ')
        .map((word: string) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
      return {
        url,
        title: (frontmatter as any)?.title || capitalizedTitle,
        slug,
      };
    })
    .sort((a, b) => a.title.localeCompare(b.title));
}

/**
 * Get all pages including nested ones (for sitemap generation)
 * 
 * Usage:
 * ```astro
 * ---
 * import { getAllNavigationPages } from '../lib/navigation';
 * const allPages = await getAllNavigationPages();
 * ---
 * ```
 */
export async function getAllNavigationPages(): Promise<NavigationPage[]> {
  const pageFiles = import.meta.glob('../pages/**/*.{md,mdx,astro}', { eager: true });
  
  // Convert file paths to URLs
  return Object.entries(pageFiles)
    .map(([filePath, module]) => {
      // Convert file path to URL: '../pages/products/index.astro' -> '/products'
      let url = filePath
        .replace('../pages', '')
        .replace(/\.astro$/, '')
        .replace(/\.mdx?$/, '')
        .replace(/\/index$/, '') // /products/index -> /products
        || '/';
      
      const frontmatter = module && typeof module === 'object' && 'frontmatter' in module 
        ? (module as any).frontmatter 
        : {};
      
      return { filePath, url, frontmatter };
    })
    .filter(({ url, filePath }) => {
      return (
        url !== '/404' &&
        url !== '/offline' &&
        !filePath.includes('[') && 
        !filePath.includes(']')
      );
    })
    .map(({ url, frontmatter }) => {
      const segments = url.split('/').filter(Boolean);
      const lastSegment = segments[segments.length - 1] || 'home';
      const defaultTitle = lastSegment.replace(/-/g, ' ').replace(/_/g, ' ');
      const capitalizedTitle = defaultTitle
        .split(' ')
        .map((word: string) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
      return {
        url: url || '/',
        title: (frontmatter as any)?.title || capitalizedTitle,
        slug: lastSegment,
      };
    })
    .sort((a, b) => a.url.localeCompare(b.url));
}

// ============================================================================
// Path Utilities
// ============================================================================

/**
 * Check if a path matches the current path (for active state styling)
 * 
 * Usage:
 * ```astro
 * ---
 * import { isActivePath } from '../lib/navigation';
 * const currentPath = Astro.url.pathname;
 * ---
 * 
 * <a 
 *   href="/blog" 
 *   class={isActivePath(currentPath, '/blog') ? 'active' : ''}
 * >
 *   Blog
 * </a>
 * ```
 * 
 * @param currentPath - The current page path
 * @param targetPath - The path to check against
 * @param exact - If true, requires exact match. If false, checks if current path starts with target
 */
export function isActivePath(currentPath: string, targetPath: string, exact: boolean = false): boolean {
  // Normalize paths - remove trailing slashes
  const normalized = currentPath.replace(/\/$/, '') || '/';
  const target = targetPath.replace(/\/$/, '') || '/';
  
  if (exact || target === '/') {
    return normalized === target;
  }
  
  return normalized === target || normalized.startsWith(target + '/');
}

/**
 * Get the active nav class based on current path
 * 
 * Usage:
 * ```astro
 * ---
 * import { getActiveClass } from '../lib/navigation';
 * const currentPath = Astro.url.pathname;
 * ---
 * 
 * <a href="/blog" class={getActiveClass(currentPath, '/blog', 'text-blue-600', 'text-gray-600')}>
 *   Blog
 * </a>
 * ```
 */
export function getActiveClass(
  currentPath: string, 
  targetPath: string, 
  activeClass: string = 'active', 
  inactiveClass: string = ''
): string {
  return isActivePath(currentPath, targetPath) ? activeClass : inactiveClass;
}

// ============================================================================
// Breadcrumbs
// ============================================================================

/**
 * Generate breadcrumb items from a URL path
 * 
 * Usage:
 * ```astro
 * ---
 * import { getBreadcrumbs } from '../lib/navigation';
 * const breadcrumbs = getBreadcrumbs(Astro.url.pathname);
 * ---
 * 
 * <nav aria-label="Breadcrumb">
 *   <ol>
 *     {breadcrumbs.map((crumb, i) => (
 *       <li>
 *         {crumb.current ? (
 *           <span aria-current="page">{crumb.label}</span>
 *         ) : (
 *           <a href={crumb.href}>{crumb.label}</a>
 *         )}
 *       </li>
 *     ))}
 *   </ol>
 * </nav>
 * ```
 */
export function getBreadcrumbs(pathname: string, homeLabel: string = 'Home'): BreadcrumbItem[] {
  const segments = pathname.split('/').filter(Boolean);
  const breadcrumbs: BreadcrumbItem[] = [
    { label: homeLabel, href: '/', current: segments.length === 0 }
  ];
  
  let currentPath = '';
  segments.forEach((segment, index) => {
    currentPath += '/' + segment;
    const label = segment
      .replace(/-/g, ' ')
      .replace(/_/g, ' ')
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
    
    breadcrumbs.push({
      label,
      href: currentPath,
      current: index === segments.length - 1,
    });
  });
  
  return breadcrumbs;
}

// ============================================================================
// URL Utilities
// ============================================================================

/**
 * Get the slug from a URL path
 * 
 * Usage:
 * ```
 * getSlug('/blog/my-post') // 'my-post'
 * getSlug('/about') // 'about'
 * ```
 */
export function getSlug(path: string): string {
  const segments = path.split('/').filter(Boolean);
  return segments[segments.length - 1] || '';
}

/**
 * Get the parent path from a URL
 * 
 * Usage:
 * ```
 * getParentPath('/blog/my-post') // '/blog'
 * getParentPath('/about') // '/'
 * ```
 */
export function getParentPath(path: string): string {
  const segments = path.split('/').filter(Boolean);
  if (segments.length <= 1) return '/';
  return '/' + segments.slice(0, -1).join('/');
}

/**
 * Check if a path is a child of another path
 * 
 * Usage:
 * ```
 * isChildPath('/blog/my-post', '/blog') // true
 * isChildPath('/about', '/blog') // false
 * ```
 */
export function isChildPath(childPath: string, parentPath: string): boolean {
  const normalizedChild = childPath.replace(/\/$/, '');
  const normalizedParent = parentPath.replace(/\/$/, '');
  
  if (normalizedParent === '/') {
    return normalizedChild.split('/').filter(Boolean).length === 1;
  }
  
  return normalizedChild.startsWith(normalizedParent + '/');
}

/**
 * Join URL path segments safely
 * 
 * Usage:
 * ```
 * joinPaths('/blog', 'my-post') // '/blog/my-post'
 * joinPaths('/blog/', '/my-post/') // '/blog/my-post'
 * ```
 */
export function joinPaths(...segments: string[]): string {
  return '/' + segments
    .map(s => s.replace(/^\/+|\/+$/g, ''))
    .filter(Boolean)
    .join('/');
}
